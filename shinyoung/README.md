# 📝 면접 질문 정리

---

## 📅 2025-05-14

### 질문 1
**Q.** iOS 앱에서 데이터를 저장하는 방법에는 어떤 것들이 있나요?

**A.**  
    `UserDefaults`로 간단한 설정 값을 저장하고 이미지, PDF, JSON 등을 `FileManager`를 통해 파일 단위로 저장할 수 있습니다.  
    토큰, 비밀번호 등 민감 정보는 `Keychain`에 저장할 수 있습니다.  
    엔터티 간 관계나 쿼리가 필요한 경우 관계형 모델의 영구 저장소인 `Core Data`를 사용할 수 있습니다.  
    SQL 쿼리를 직접 제어하고 싶을 때는 `SQLite`로 경량 데이터베이스를 직접 사용할 수 있습니다.  
    서드파티 NoSQL 데이터베이스인 `Realm`을 사용하면 `Core Data` 보다 더 직관적이고 빠르게 모델을 저장할 수 있습니다.  
    
    데이터의 복잡도에 따라 `UserDefaults`와 `Keychain`은 Key-Value 등 비교적 단순한 단일값을 다루며,  
    `CoreData`, `Realm`, `FileManager`, `SQLite`는 여러 속성, 관계, 리스트, 복합 타입 등 구조화된 데이터를 다룹니다.  
    `UserDefaults`와 `Keychain`은 앱 설정이나 사용자 기본 정보를 Key로 직접 접근할 수 있으며 데이터 간 관계가 거의 없거나 약합니다.  
    `CoreData`, `Realm`, `FileManager`, `SQLite`는 앱의 주요 컨텐츠나 기능을 위한 데이터를 저장하며 조건 검색, 정렬, 필터링 기능을 제공합니다.

---

## 📅 2025-05-15

### 질문 1
**Q.** Swift에서 클로저(Closure)란 무엇이며, 어떻게 사용하나요?

**A.** 클로저는 코드 블록을 변수처럼 사용할 수 있는 기능으로, 익명 함수의 일종입니다. 함수와 유사하게 동작하며, 특정 동작을 캡슐화하고 나중에 실행하거나 전달할 수 있습니다.
클로저의 캡처 기능은 클로저가 정의된 외부의 변수나 상수를 클로저 내부에서 사용할 수 있도록 하는 기능입니다. 이 기능을 사용하여 클로저가 나중에 실행될 때도 해당 값에 접근하거나
변경할 수 있습니다. 클로저가 참조한 변수는 클로저의 수명과 함께 유지됩니다. @escaping과 non-escaping 클로저의 차이점은 클로저가 함수의 생명주기 안에서 실행되는지, 
아니면 나중에 실행되는지에 따라 나뉩니다. 기본적으로 함수 내부에서 바로 실행되는 클로저는 @escaping 키워드를 명시할 필요 없으며, 네트워크 콜백 등과 같이 비동기 처리시 함수 종료 이후에 사용되는 
클로저에는 키워드를 명시해야합니다. @escaping 클로저는 self를 강하게 캡처하므로, weak, unowned 사용으로 순환 참조 방지가 필요합니다. 함수의 마지막 파라미터가 클로저일때 트레일링 클로저 문법을
사용하면 해당 클로저를 함수 괄호 바깥으로 빼서 간결하고 읽기 쉬운 형태로 작성할 수 있습니다.

---

## 📅 2025-05-20

### 질문 1
**Q.** Swift의 문자열(String) 다루기와 관련된 주요 기능은 무엇이 있나요?

**A.** Swift에서 문자열(String)을 다룰 때 자주 사용하는 기능으로는 문자열 생성 및 초기화, 길이 확인(count), 인덱스를 활용한 문자 접근, Substring을 통한 문자열 자르기, + 연산 또는 보간법("\(value)")을 이용한 문자열 결합, 특정 문자열 포함 여부 확인(contains), 문자열 비교 및 대소문자 변환, 부분 문자열 치환(replacingOccurrences), 문자열 분리(components(separatedBy:)), 앞뒤 공백 제거(trimmingCharacters), 멀티라인 문자열(""" """) 사용 등이 있으며, iOS 개발에서는 이러한 기능들을 사용자 입력 처리, 로그 메시지 생성, 서버와의 통신 데이터 처리 등에 자주 활용합니다.

Swift의 고급 문자열 기능에는 prefix, suffix, dropFirst 등으로 부분 문자열을 추출하거나 제거하는 기능, split(separator:)과 range(of:)를 통한 문자열 분할 및 탐색, 정규표현식을 활용한 패턴 검색 및 치환(NSRegularExpression), filter, map, reduce 같은 고차함수를 이용한 문자 단위 가공, removeSubrange나 append와 같은 직접적인 문자열 수정, 유니코드 스칼라 접근, 그리고 AttributedString을 통한 스타일 적용 등이 포함됩니다. 이러한 기능은 단순 출력이나 비교를 넘어 사용자 입력 검증, 텍스트 마스킹, 고급 UI 표현, 다국어 처리 등 정교한 문자열 조작이 필요한 iOS 앱 개발에 특히 유용합니다.

### 질문 2
**Q.** 서브스트링(Substring)과 문자열의 차이점은 무엇인가요?

**A.** Swift에서 Substring은 기존 String의 일부를 참조하는 경량 뷰(View)로, 원본 문자열의 메모리를 공유하여 메모리 복사를 피하고 성능을 높일 수 있는 장점이 있습니다. 예를 들어 split, prefix, suffix 등의 메서드는 기본적으로 Substring을 반환하며, 이는 문자열의 일부분을 빠르게 다룰 수 있도록 설계된 것입니다.

하지만 Substring은 원본 문자열에 의존하기 때문에 수명이 짧고, 원본 String이 해제되면 메모리 접근 오류가 발생할 수 있습니다. 따라서 Substring을 장기적으로 보관하거나 다른 객체에 전달할 경우에는 반드시 String(substring)으로 변환해 독립적인 메모리를 가지도록 해야 안전합니다.

---

## 📅 2025-05-22

### 질문 1
**Q.** Swift의 제네릭(Generic)에 대해 설명해주세요.

**A.** 제네릭은 다양한 타입에 대해 하나의 함수나 타입(클래스, 구조체 등)을 재사용할 수 있도록 해주는 기능으로, 코드의 중복을 줄이고 타입 안전성을 보장합니다. 예를 들어 타입 매개변수 T를 사용하면 Int, String 등 어떤 타입이든 유연하게 사용할 수 있습니다. 또한 T: Equatable처럼 제약을 걸어 특정 프로토콜을 따르는 타입만 허용할 수도 있습니다. Array, Dictionary, Optional 등 Swift의 주요 타입들도 모두 제네릭 기반입니다. iOS 개발에서는 UITableView나 UICollectionView의 셀 등록 및 재사용 메서드에 제네릭을 활용해 타입 안정성과 코드 간결성을 높이는 데 자주 사용됩니다.

### 질문 2
**Q.** 제네릭을 사용하는 이유는 무엇인가요?

**A.** 제네릭을 사용하는 이유는 코드의 중복을 줄이고, 다양한 타입에 대해 재사용 가능하며, 컴파일 타임에 타입 안정성을 확보할 수 있기 때문입니다. 예를 들어, 같은 기능을 Int, String, Double 등에 대해 각각 따로 구현하는 대신 제네릭을 사용하면 하나의 코드로 여러 타입을 처리할 수 있어 유지보수성이 높아지고 코드가 더 간결해집니다. 또한, 타입을 명확하게 지정하지 않아도 컴파일 시점에 타입이 결정되므로 타입 오류를 방지할 수 있어 안전한 프로그래밍이 가능합니다. Array, Dictionary, Optional 같은 기본 타입들도 모두 제네릭으로 구현되어 있으며, iOS 개발에서도 셀 재사용이나 네트워크 응답 파싱 등 다양한 상황에서 제네릭이 활용됩니다.

### 질문 3 
**Q.** 제네릭 타입 파라미터(Generic Type Parameter)와 제네릭 타입 제약(Generic Type Constraint)은 무엇인가요?

**A.** 제네릭 함수나 타입을 정의할 때 어떤 타입이 들어올지 미리 정하지 않고 임의의 타입으로 일반화하기 위해 사용됩니다. 일반적으로 T, U, Element 등의 이름으로 사용되며, 실제 사용 시점에 구체적인 타입으로 대체됩니다. 제네릭 타입 제약은 제네릭 타입이 특정 조건(프로토콜 채택 등)을 만족하는 타입으로만 제한되도록 설정하는 기능입니다. where 키워드나 : 기호를 사용해 타입 파라미터에 조건을 걸 수 있습니다.

### 질문 4
**Q.** 제네릭을 사용할 때 주의할 점은 무엇인가요?

**A.** Swift에서 제네릭을 사용할 때는 타입 제약 없이 너무 일반화하면 내부에서 할 수 있는 작업이 제한되므로 필요한 경우 Equatable, Codable 등의 프로토콜 제약을 명시해야 하며, 과도하게 복잡한 제네릭 구성은 오히려 가독성을 떨어뜨릴 수 있습니다. 또한 Swift의 제네릭은 컴파일 타임에 타입이 결정되기 때문에 런타임에 타입 정보를 동적으로 활용하기 어렵고, associatedtype을 가진 프로토콜은 일반 타입처럼 직접 사용할 수 없어 구체적인 타입으로 제약을 줘야 합니다.

---

## 📅 2025-05-26

### 질문 1
**Q.** REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.

**A.** REST(Representational State Transfer)는 웹 기반 시스템에서 자원(리소스)을 효율적으로 관리하고 상호작용할 수 있도록 설계된 아키텍처 스타일입니다. 이 방식은 HTTP 프로토콜을 기반으로 동작하며, 서버에 존재하는 자원을 고유한 URL로 표현합니다. 예를 들어, https://api.example.com/users/1이라는 URL은 사용자 ID가 1번인 자원을 의미합니다.

REST에서는 이러한 리소스에 접근하거나 조작할 때 HTTP 메서드를 사용합니다. GET 메서드는 리소스를 조회할 때 사용되며, 서버의 상태를 변경하지 않습니다. POST는 새로운 리소스를 생성할 때 사용되고, PUT은 기존 리소스를 수정할 때 사용됩니다. DELETE는 특정 리소스를 삭제하는 데 사용됩니다.

이러한 방식은 클라이언트가 서버의 리소스를 URL과 HTTP 메서드만으로 명확하게 다룰 수 있게 해주며, 전체 API 구조를 간결하고 예측 가능하게 만듭니다. REST는 iOS 앱을 포함한 다양한 플랫폼에서 서버와 데이터를 주고받는 표준적인 방식으로 널리 사용되고 있습니다.

REST API는 REST 아키텍처 스타일을 따르는 웹 기반의 API입니다. 이는 클라이언트와 서버가 서로 데이터를 주고받을 수 있도록 정의된 일종의 인터페이스이며, HTTP 프로토콜을 기반으로 동작합니다. 클라이언트는 특정한 URL을 통해 서버에 자원을 요청하고, 서버는 이에 대한 데이터를 응답으로 반환합니다.

이러한 방식은 통신 구조를 단순하고 예측 가능하게 만들어주기 때문에, iOS 앱을 포함한 다양한 플랫폼에서 서버와 데이터를 주고받는 기본적인 통신 방식으로 널리 사용되고 있습니다.

iOS 앱에서 네트워크 요청을 처리할 때는 먼저 통신할 서버의 주소를 나타내는 URL을 생성합니다. 이후 해당 URL을 기반으로 URLRequest 객체를 만들고, 이 객체에 HTTP 메서드(GET, POST 등), 요청 헤더, 요청 바디 등을 설정합니다. 이렇게 준비된 요청은 URLSession을 통해 서버로 전송됩니다.

요청이 전송되면, 서버는 이에 대한 응답을 Data, URLResponse, 그리고 Error 형태로 반환합니다. 개발자는 이 응답을 비동기적으로 받아 처리하며, 서버에서 받은 JSON 데이터를 Swift의 Codable을 사용해 앱에서 사용할 수 있는 모델 타입으로 디코딩합니다.

네트워크 작업은 기본적으로 메인 스레드가 아닌 백그라운드에서 이루어지기 때문에, UI 업데이트가 필요한 경우에는 반드시 메인 스레드에서 작업을 수행해야 합니다. 이를 위해 DispatchQueue.main.async 블록을 사용합니다.

또한, iOS에서는 URLSession 외에도 Alamofire와 같은 서드파티 라이브러리를 활용하여 보다 간결하고 강력하게 네트워크 요청을 처리할 수도 있으며, Swift 5.5 이후부터는 async/await 문법을 통해 네트워크 코드를 더 간결하게 작성할 수 있게 되었습니다.

이러한 방식으로 iOS 앱은 외부 서버와 안전하고 효율적으로 데이터를 주고받으며, 사용자에게 실시간 정보를 제공하거나 서버에 정보를 저장할 수 있습니다.

---

## 📅 2025-05-27

### 질문 1
**Q.** 싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?

**A.** 싱글톤 패턴은 특정 클래스의 인스턴스를 프로그램 전체에서 단 하나만 생성되도록 제한하는 디자인 패턴입니다. 이 인스턴스는 전역적으로 접근 가능하도록 설계되어, 어디서든 동일한 객체를 참조할 수 있습니다. 또한, 인스턴스를 생성하는 시점을 개발자가 제어할 수 있기 때문에, 필요할 때까지 인스턴스를 생성하지 않고 대기하는 지연 초기화와 같은 전략을 사용할 수 있습니다. 이로 인해 메모리 낭비를 방지하고, 리소스 효율적인 객체 관리가 가능합니다.

예를 들어, 네트워크 요청을 처리하는 NetworkManager, 사용자 인증 상태를 유지하는 UserSession, 앱 전반에서 설정 정보를 공유하는 SettingsManager 같은 경우에 싱글톤이 유용합니다.

**Q.** 싱글톤 패턴의 장점과 단점을 설명해주세요.

**A.** 싱글톤 패턴의 가장 큰 장점은 앱 전역에서 동일한 인스턴스를 공유함으로써 상태의 일관성을 유지하고, 중복 인스턴스 생성으로 인한 버그를 예방할 수 있다는 점입니다. 예를 들어, 사용자 로그인 정보나 설정 값처럼 하나의 상태를 유지해야 하는 경우, 여러 인스턴스가 생성되면 서로 다른 상태를 가질 수 있어 예기치 않은 오류가 발생할 수 있는데, 싱글톤은 이를 원천적으로 차단합니다.

또한, 네트워크 매니저, 데이터베이스 연결 객체 등과 같이 리소스 사용 비용이 큰 객체를 한 번만 생성하고 재사용할 수 있어 시스템 자원을 효율적으로 관리할 수 있습니다. 이와 함께, 특정 기능을 어디에서든 사용할 수 있는 전역 접근성을 제공하므로, 구조가 단순한 프로젝트에서는 코드를 간결하게 유지하고 구현 속도를 높이는 데에도 유리합니다.

싱글톤 패턴을 사용할 때는 몇 가지 주의할 점이 있습니다.

첫째, 테스트가 어려울 수 있습니다. 싱글톤 객체는 전역에서 접근 가능한 하나의 인스턴스를 사용하기 때문에, 유닛 테스트 시 해당 객체를 다른 가짜(mock) 객체로 대체하기 어렵습니다. 이렇게 되면 테스트가 실제 싱글톤 인스턴스에 의존하게 되어, 독립적인 테스트 수행이 어려워지고 테스트 결과에 영향을 줄 수 있습니다.

둘째, 의존성이 코드상에 명확하게 드러나지 않기 때문에 추적이 어렵습니다. 일반적으로는 객체가 필요한 의존성을 생성자나 메서드 등을 통해 전달받는 의존성 주입 방식을 사용하면 코드의 흐름이 명확해지지만, 싱글톤은 전역 접근이 가능하기 때문에 어디서든 호출될 수 있고, 어떤 객체가 어떤 의존성을 사용하는지 파악하기 어려워집니다. 이는 코드 유지보수성과 가독성을 떨어뜨릴 수 있습니다.

셋째, 메모리 누수의 위험이 존재합니다. 싱글톤 객체가 다른 객체를 강한 참조로 유지하고 있는 경우, 해당 객체가 더 이상 사용되지 않더라도 메모리에서 해제되지 않아 메모리 누수가 발생할 수 있습니다. 특히 iOS 환경에서는 ARC에 의해 메모리 관리가 자동으로 이루어지는데, 순환 참조가 발생하면 메모리가 제대로 해제되지 않기 때문에 주의가 필요합니다.

---

## 📅 2025-05-27

### 질문 1
**Q.** 프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.

**A.** 프로세스와 스레드는 iOS 개발에서 앱의 실행 구조와 성능 최적화에 중요한 개념입니다. 프로세스는 실행 중인 프로그램의 인스턴스를 의미하며, 이는 단순히 하드디스크에 저장된 정적인 실행 파일이 아닌, 메모리에 올라가 운영체제가 자원을 할당하고 고유한 프로세스 ID(PID)를 부여한 상태를 말합니다. 예를 들어, 사용자가 Safari 앱을 실행하면 운영체제는 이 앱의 실행 파일을 메모리에 적재하고, 필요한 시스템 자원을 할당하며, 하나의 독립된 프로세스로 관리하게 됩니다. 이처럼 프로세스는 운영체제 관점에서 메모리, 파일 핸들, 네트워크 소켓 등을 포함한 고립된 실행 환경이며, 하나의 프로그램이 실제로 살아 움직이는 상태를 뜻합니다.

반면, 스레드는 이 프로세스 내부에서 실행 흐름을 담당하는 최소 단위입니다. 하나의 프로세스는 반드시 하나 이상의 스레드를 가지며, 일반적으로 앱 실행 시 자동으로 생성되는 메인 스레드가 존재합니다. 이 메인 스레드는 사용자 인터페이스(UI)를 그리는 역할을 담당하며, 추가로 생성되는 스레드는 네트워크 처리나 백그라운드 연산 등 다른 작업을 병렬로 수행합니다. 스레드는 같은 프로세스 안에서 코드, 전역 변수, 힙 메모리 등을 공유하지만, 호출 스택(stack)과 레지스터 상태는 각각 독립적으로 유지됩니다. 따라서 스레드는 여러 작업을 동시에 처리할 수 있어 앱의 응답성을 높일 수 있지만, 자원을 공유하는 구조이기 때문에 동기화 문제가 발생할 수 있어 주의가 필요합니다.

iOS에서는 이러한 스레드와 프로세스를 직접적으로 제어하기보다는, 운영체제가 제공하는 추상화된 도구들을 활용해 간접적으로 다루는 방식이 일반적입니다. 대표적으로 Grand Central Dispatch(GCD)는 간결한 API로 비동기 작업을 스레드 큐에 등록할 수 있게 하며, DispatchQueue.global().async를 통해 백그라운드 작업을 수행하고, DispatchQueue.main.async를 사용하여 UI 업데이트를 메인 스레드에서 처리할 수 있습니다. OperationQueue는 GCD보다 정교한 기능을 제공하여 작업 간 의존성, 우선순위 설정, 취소 등의 기능을 포함합니다. 더 나아가 iOS 15 이상에서는 Swift의 async/await 문법을 통해 스레드를 직접 관리하지 않아도 자연스럽게 비동기 코드를 작성할 수 있으며, Task를 통해 간결하게 백그라운드 작업과 UI 갱신을 분리할 수 있습니다.

결국 프로세스는 앱 실행의 독립된 단위이며, 스레드는 이 프로세스 안에서 실제 작업을 수행하는 실행 흐름입니다. iOS는 각 앱을 하나의 프로세스로 실행하고, 그 안에서 여러 스레드를 활용하여 사용자 인터페이스와 백그라운드 작업을 동시에 처리할 수 있도록 합니다. 이러한 구조를 이해하고 적절히 활용하면 앱의 반응성과 안정성을 높일 수 있으며, 특히 UI는 반드시 메인 스레드에서 처리하고, 시간이 오래 걸리는 작업은 백그라운드 스레드로 분리하여 실행해야 한다는 점을 항상 염두에 두어야 합니다.

---
