# 📝 면접 질문 정리

---

## 📅 2025-05-14

### 질문 1
**Q.** iOS 앱에서 데이터를 저장하는 방법에는 어떤 것들이 있나요?

**A.**  
    `UserDefaults`로 간단한 설정 값을 저장하고 이미지, PDF, JSON 등을 `FileManager`를 통해 파일 단위로 저장할 수 있습니다.  
    토큰, 비밀번호 등 민감 정보는 `Keychain`에 저장할 수 있습니다.  
    엔터티 간 관계나 쿼리가 필요한 경우 관계형 모델의 영구 저장소인 `Core Data`를 사용할 수 있습니다.  
    SQL 쿼리를 직접 제어하고 싶을 때는 `SQLite`로 경량 데이터베이스를 직접 사용할 수 있습니다.  
    서드파티 NoSQL 데이터베이스인 `Realm`을 사용하면 `Core Data` 보다 더 직관적이고 빠르게 모델을 저장할 수 있습니다.  
    
    데이터의 복잡도에 따라 `UserDefaults`와 `Keychain`은 Key-Value 등 비교적 단순한 단일값을 다루며,  
    `CoreData`, `Realm`, `FileManager`, `SQLite`는 여러 속성, 관계, 리스트, 복합 타입 등 구조화된 데이터를 다룹니다.  
    `UserDefaults`와 `Keychain`은 앱 설정이나 사용자 기본 정보를 Key로 직접 접근할 수 있으며 데이터 간 관계가 거의 없거나 약합니다.  
    `CoreData`, `Realm`, `FileManager`, `SQLite`는 앱의 주요 컨텐츠나 기능을 위한 데이터를 저장하며 조건 검색, 정렬, 필터링 기능을 제공합니다.

---

## 📅 2025-05-15

### 질문 1
**Q.** Swift에서 클로저(Closure)란 무엇이며, 어떻게 사용하나요?

**A.** 클로저는 코드 블록을 변수처럼 사용할 수 있는 기능으로, 익명 함수의 일종입니다. 함수와 유사하게 동작하며, 특정 동작을 캡슐화하고 나중에 실행하거나 전달할 수 있습니다.
클로저의 캡처 기능은 클로저가 정의된 외부의 변수나 상수를 클로저 내부에서 사용할 수 있도록 하는 기능입니다. 이 기능을 사용하여 클로저가 나중에 실행될 때도 해당 값에 접근하거나
변경할 수 있습니다. 클로저가 참조한 변수는 클로저의 수명과 함께 유지됩니다. @escaping과 non-escaping 클로저의 차이점은 클로저가 함수의 생명주기 안에서 실행되는지, 
아니면 나중에 실행되는지에 따라 나뉩니다. 기본적으로 함수 내부에서 바로 실행되는 클로저는 @escaping 키워드를 명시할 필요 없으며, 네트워크 콜백 등과 같이 비동기 처리시 함수 종료 이후에 사용되는 
클로저에는 키워드를 명시해야합니다. @escaping 클로저는 self를 강하게 캡처하므로, weak, unowned 사용으로 순환 참조 방지가 필요합니다. 함수의 마지막 파라미터가 클로저일때 트레일링 클로저 문법을
사용하면 해당 클로저를 함수 괄호 바깥으로 빼서 간결하고 읽기 쉬운 형태로 작성할 수 있습니다.

---

## 📅 2025-05-20

### 질문 1
**Q.** Swift의 문자열(String) 다루기와 관련된 주요 기능은 무엇이 있나요?

**A.** Swift에서 문자열(String)을 다룰 때 자주 사용하는 기능으로는 문자열 생성 및 초기화, 길이 확인(count), 인덱스를 활용한 문자 접근, Substring을 통한 문자열 자르기, + 연산 또는 보간법("\(value)")을 이용한 문자열 결합, 특정 문자열 포함 여부 확인(contains), 문자열 비교 및 대소문자 변환, 부분 문자열 치환(replacingOccurrences), 문자열 분리(components(separatedBy:)), 앞뒤 공백 제거(trimmingCharacters), 멀티라인 문자열(""" """) 사용 등이 있으며, iOS 개발에서는 이러한 기능들을 사용자 입력 처리, 로그 메시지 생성, 서버와의 통신 데이터 처리 등에 자주 활용합니다.

Swift의 고급 문자열 기능에는 prefix, suffix, dropFirst 등으로 부분 문자열을 추출하거나 제거하는 기능, split(separator:)과 range(of:)를 통한 문자열 분할 및 탐색, 정규표현식을 활용한 패턴 검색 및 치환(NSRegularExpression), filter, map, reduce 같은 고차함수를 이용한 문자 단위 가공, removeSubrange나 append와 같은 직접적인 문자열 수정, 유니코드 스칼라 접근, 그리고 AttributedString을 통한 스타일 적용 등이 포함됩니다. 이러한 기능은 단순 출력이나 비교를 넘어 사용자 입력 검증, 텍스트 마스킹, 고급 UI 표현, 다국어 처리 등 정교한 문자열 조작이 필요한 iOS 앱 개발에 특히 유용합니다.

### 질문 2
**Q.** 서브스트링(Substring)과 문자열의 차이점은 무엇인가요?

**A.** Swift에서 Substring은 기존 String의 일부를 참조하는 경량 뷰(View)로, 원본 문자열의 메모리를 공유하여 메모리 복사를 피하고 성능을 높일 수 있는 장점이 있습니다. 예를 들어 split, prefix, suffix 등의 메서드는 기본적으로 Substring을 반환하며, 이는 문자열의 일부분을 빠르게 다룰 수 있도록 설계된 것입니다.

하지만 Substring은 원본 문자열에 의존하기 때문에 수명이 짧고, 원본 String이 해제되면 메모리 접근 오류가 발생할 수 있습니다. 따라서 Substring을 장기적으로 보관하거나 다른 객체에 전달할 경우에는 반드시 String(substring)으로 변환해 독립적인 메모리를 가지도록 해야 안전합니다.

---

## 📅 2025-05-22

### 질문 1
**Q.** Swift의 제네릭(Generic)에 대해 설명해주세요.

**A.** 제네릭은 다양한 타입에 대해 하나의 함수나 타입(클래스, 구조체 등)을 재사용할 수 있도록 해주는 기능으로, 코드의 중복을 줄이고 타입 안전성을 보장합니다. 예를 들어 타입 매개변수 T를 사용하면 Int, String 등 어떤 타입이든 유연하게 사용할 수 있습니다. 또한 T: Equatable처럼 제약을 걸어 특정 프로토콜을 따르는 타입만 허용할 수도 있습니다. Array, Dictionary, Optional 등 Swift의 주요 타입들도 모두 제네릭 기반입니다. iOS 개발에서는 UITableView나 UICollectionView의 셀 등록 및 재사용 메서드에 제네릭을 활용해 타입 안정성과 코드 간결성을 높이는 데 자주 사용됩니다.

### 질문 2
**Q.** 제네릭을 사용하는 이유는 무엇인가요?

**A.** 제네릭을 사용하는 이유는 코드의 중복을 줄이고, 다양한 타입에 대해 재사용 가능하며, 컴파일 타임에 타입 안정성을 확보할 수 있기 때문입니다. 예를 들어, 같은 기능을 Int, String, Double 등에 대해 각각 따로 구현하는 대신 제네릭을 사용하면 하나의 코드로 여러 타입을 처리할 수 있어 유지보수성이 높아지고 코드가 더 간결해집니다. 또한, 타입을 명확하게 지정하지 않아도 컴파일 시점에 타입이 결정되므로 타입 오류를 방지할 수 있어 안전한 프로그래밍이 가능합니다. Array, Dictionary, Optional 같은 기본 타입들도 모두 제네릭으로 구현되어 있으며, iOS 개발에서도 셀 재사용이나 네트워크 응답 파싱 등 다양한 상황에서 제네릭이 활용됩니다.

### 질문 3 
**Q.** 제네릭 타입 파라미터(Generic Type Parameter)와 제네릭 타입 제약(Generic Type Constraint)은 무엇인가요?

**A.** 제네릭 함수나 타입을 정의할 때 어떤 타입이 들어올지 미리 정하지 않고 임의의 타입으로 일반화하기 위해 사용됩니다. 일반적으로 T, U, Element 등의 이름으로 사용되며, 실제 사용 시점에 구체적인 타입으로 대체됩니다. 제네릭 타입 제약은 제네릭 타입이 특정 조건(프로토콜 채택 등)을 만족하는 타입으로만 제한되도록 설정하는 기능입니다. where 키워드나 : 기호를 사용해 타입 파라미터에 조건을 걸 수 있습니다.

### 질문 4
**Q.** 제네릭을 사용할 때 주의할 점은 무엇인가요?

**A.** Swift에서 제네릭을 사용할 때는 타입 제약 없이 너무 일반화하면 내부에서 할 수 있는 작업이 제한되므로 필요한 경우 Equatable, Codable 등의 프로토콜 제약을 명시해야 하며, 과도하게 복잡한 제네릭 구성은 오히려 가독성을 떨어뜨릴 수 있습니다. 또한 Swift의 제네릭은 컴파일 타임에 타입이 결정되기 때문에 런타임에 타입 정보를 동적으로 활용하기 어렵고, associatedtype을 가진 프로토콜은 일반 타입처럼 직접 사용할 수 없어 구체적인 타입으로 제약을 줘야 합니다.

---
