# 📝 면접 질문 정리

---

## 📅 2025-05-14

### 질문 1
**Q.** iOS 앱에서 데이터를 저장하는 방법에는 어떤 것들이 있나요?

**A.**  
    `UserDefaults`로 간단한 설정 값을 저장하고 이미지, PDF, JSON 등을 `FileManager`를 통해 파일 단위로 저장할 수 있습니다.  
    토큰, 비밀번호 등 민감 정보는 `Keychain`에 저장할 수 있습니다.  
    엔터티 간 관계나 쿼리가 필요한 경우 관계형 모델의 영구 저장소인 `Core Data`를 사용할 수 있습니다.  
    SQL 쿼리를 직접 제어하고 싶을 때는 `SQLite`로 경량 데이터베이스를 직접 사용할 수 있습니다.  
    서드파티 NoSQL 데이터베이스인 `Realm`을 사용하면 `Core Data` 보다 더 직관적이고 빠르게 모델을 저장할 수 있습니다.  
    
    데이터의 복잡도에 따라 `UserDefaults`와 `Keychain`은 Key-Value 등 비교적 단순한 단일값을 다루며,  
    `CoreData`, `Realm`, `FileManager`, `SQLite`는 여러 속성, 관계, 리스트, 복합 타입 등 구조화된 데이터를 다룹니다.  
    `UserDefaults`와 `Keychain`은 앱 설정이나 사용자 기본 정보를 Key로 직접 접근할 수 있으며 데이터 간 관계가 거의 없거나 약합니다.  
    `CoreData`, `Realm`, `FileManager`, `SQLite`는 앱의 주요 컨텐츠나 기능을 위한 데이터를 저장하며 조건 검색, 정렬, 필터링 기능을 제공합니다.

---

## 📅 2025-05-15

### 질문 1
**Q.** Swift에서 클로저(Closure)란 무엇이며, 어떻게 사용하나요?

**A.** 클로저는 코드 블록을 변수처럼 사용할 수 있는 기능으로, 익명 함수의 일종입니다. 함수와 유사하게 동작하며, 특정 동작을 캡슐화하고 나중에 실행하거나 전달할 수 있습니다.
클로저의 캡처 기능은 클로저가 정의된 외부의 변수나 상수를 클로저 내부에서 사용할 수 있도록 하는 기능입니다. 이 기능을 사용하여 클로저가 나중에 실행될 때도 해당 값에 접근하거나
변경할 수 있습니다. 클로저가 참조한 변수는 클로저의 수명과 함께 유지됩니다. @escaping과 non-escaping 클로저의 차이점은 클로저가 함수의 생명주기 안에서 실행되는지, 
아니면 나중에 실행되는지에 따라 나뉩니다. 기본적으로 함수 내부에서 바로 실행되는 클로저는 @escaping 키워드를 명시할 필요 없으며, 네트워크 콜백 등과 같이 비동기 처리시 함수 종료 이후에 사용되는 
클로저에는 키워드를 명시해야합니다. @escaping 클로저는 self를 강하게 캡처하므로, weak, unowned 사용으로 순환 참조 방지가 필요합니다. 함수의 마지막 파라미터가 클로저일때 트레일링 클로저 문법을
사용하면 해당 클로저를 함수 괄호 바깥으로 빼서 간결하고 읽기 쉬운 형태로 작성할 수 있습니다.

---

## 📅 2025-05-20

### 질문 1
**Q.** Swift의 문자열(String) 다루기와 관련된 주요 기능은 무엇이 있나요?

**A.** Swift에서 문자열(String)을 다룰 때 자주 사용하는 기능으로는 문자열 생성 및 초기화, 길이 확인(count), 인덱스를 활용한 문자 접근, Substring을 통한 문자열 자르기, + 연산 또는 보간법("\(value)")을 이용한 문자열 결합, 특정 문자열 포함 여부 확인(contains), 문자열 비교 및 대소문자 변환, 부분 문자열 치환(replacingOccurrences), 문자열 분리(components(separatedBy:)), 앞뒤 공백 제거(trimmingCharacters), 멀티라인 문자열(""" """) 사용 등이 있으며, iOS 개발에서는 이러한 기능들을 사용자 입력 처리, 로그 메시지 생성, 서버와의 통신 데이터 처리 등에 자주 활용합니다.

Swift의 고급 문자열 기능에는 prefix, suffix, dropFirst 등으로 부분 문자열을 추출하거나 제거하는 기능, split(separator:)과 range(of:)를 통한 문자열 분할 및 탐색, 정규표현식을 활용한 패턴 검색 및 치환(NSRegularExpression), filter, map, reduce 같은 고차함수를 이용한 문자 단위 가공, removeSubrange나 append와 같은 직접적인 문자열 수정, 유니코드 스칼라 접근, 그리고 AttributedString을 통한 스타일 적용 등이 포함됩니다. 이러한 기능은 단순 출력이나 비교를 넘어 사용자 입력 검증, 텍스트 마스킹, 고급 UI 표현, 다국어 처리 등 정교한 문자열 조작이 필요한 iOS 앱 개발에 특히 유용합니다.

### 질문 2
**Q.** 서브스트링(Substring)과 문자열의 차이점은 무엇인가요?

**A.** Swift에서 Substring은 기존 String의 일부를 참조하는 경량 뷰(View)로, 원본 문자열의 메모리를 공유하여 메모리 복사를 피하고 성능을 높일 수 있는 장점이 있습니다. 예를 들어 split, prefix, suffix 등의 메서드는 기본적으로 Substring을 반환하며, 이는 문자열의 일부분을 빠르게 다룰 수 있도록 설계된 것입니다.

하지만 Substring은 원본 문자열에 의존하기 때문에 수명이 짧고, 원본 String이 해제되면 메모리 접근 오류가 발생할 수 있습니다. 따라서 Substring을 장기적으로 보관하거나 다른 객체에 전달할 경우에는 반드시 String(substring)으로 변환해 독립적인 메모리를 가지도록 해야 안전합니다.

---
