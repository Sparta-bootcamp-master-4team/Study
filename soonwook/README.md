# 📝 면접 질문 정리

---

## 📅 2025-05-14

### 질문 1
**Q.** iOS 앱에서 데이터를 저장하는 방법에는 어떤 것들이 있나요?
iOS 앱에서 데이터를 저장하는 방법에는 어떤 것들이 있나요?
- UserDefaults의 사용 시 주의할 점은 무엇인가요?
- Keychain은 어떤 데이터를 저장하기에 적합한가요?
- Core Data와 SQLite의 차이점은 무엇이며, 각각 언제 사용하면 좋나요?
- 
**A.** 
데이터 저장 방법에는 UserDefaults, File System, Keychain, Core Data, SQLite, CloudKit 등이 있습니다.
UserDefaults에서 가장 주의할 점은 보안입니다. 구현하기 간편하지만 암호화 되지 않고 정보가 노출될 수 있으므로 주의해야 합니다. 예를 들어, 가장 최근 사용자가 방문한 메뉴 등 방문 기록을 UserDefaults에 기록하는 방식은 간단하고 편하지만, 만약 방문 기록이 사용자의 개인사생활과 조금이라도 관련이 있을 수 있다면 안될 것입니다.
Keychain은 애플에서 만든 보안 시스템입니다. 따라서 아까 말씀드린 개인정보를 여기에 저장하는 것이 최적일 것입니다.
Core Data와 SQLite의 가장 큰 차이점은 Core Data는 애플에서 만들어서 애플 생태계와 밀접하게 연동이 되어 있고, SQLite는 iOS 보다는 외부 생태계에 더 친화적이라는 점입니다. 만약 앱과 연동된 외부 서버가 SQLite로 구성되어 있고, 긴밀한 연동이 필요하다면 SQLite가 더 좋은 선택이 될 것입니다.

## 📅 2025-05-15

### 질문 2
**Q.** Swift에서 클로저(Closure)란 무엇이며, 어떻게 사용하나요?

- 클로저의 캡처(Capture) 기능은 무엇인가요?
- @escaping 클로저와 non-escaping 클로저의 차이점은 무엇인가요?
- 트레일링 클로저(Trailing Closure) 문법은 어떤 경우에 유용한가요?
- 
**A.** 
클로저는 함수와 유사한 기능을 수행하지만, 좀더 축약된 형태라고 할 수 있습니다. 클로저는 함수처럼 이름을 가지지 않고, 좀 더 간소화한 형태로 파라미터와 반환값을 표현할 수 있습니다. 클로저는 함수를 포함하는 좀 더 상위 개념이라고 할 수 있습니다. 즉, 함수도 클로저의 한 종류입니다.
@escaping 클로저는 현재 클로저가 위치한 컨텍스트를 벗어나서 사용될 수 있습니다. 만약 이 클로저가 함수 내에 있다면 함수 밖에서도 사용될 수 있는 것입니다. 일반적으로 함수 내의 변수는 함수 범위를 벗어나는 순간 메모리에서 해제되는 것과 비교될 수 있습니다. 그래서 함수 밖으로 이벤트나 데이터를 전달할 때 활용합니다. non-escaping 클로저는 그 반대라고 할 수 있습니다. 아까 말씀드린 함수 내 지역 변수와 유사합니다.
트레일링 클로저(Trailing Closure)는 클로저가 함수의 마지막 파라미터로 올 경우, 아규먼트 레이블을 생략하고 함수의 소괄호 밖에서 표현하는 것입니다. 기능상 차이는 없지만 코드를 더 간결하게 표현할 수 있는 장점이 있습니다.

## 📅 2025-05-20

### 질문 3
**Q.** Swift의 문자열(String) 다루기와 관련된 주요 기능은 무엇이 있나요?
- 서브스트링(Substring)과 문자열의 차이점은 무엇인가요?
- 문자열 보간법(String Interpolation)을 사용하는 방법과 주의 사항을 설명해주세요.
- 정규식(Regular Expression)을 사용하여 문자열을 다루는 방법을 설명해주세요.
- 
**A.**
Swift의 String은 값 타입이지만, character 타입의 배열 형태로 구성되어 있습니다. 그래서 배열에서 기본적으로 제공하는 기능들을 사용할 수 있습니다. 예를 들어 String의 수를 .count로 세거나 subscript로 index 접근이 가능합니다. .prefix나 .suffix 등으로 일부 문자열을 추출할 수도 있습니다.
서브스트링(Substring)은 String에서 prefix나 subscript로 일부 문자를 떼어 냈을 때, 이것을 String 인스턴스가 아닌 SubString 인스턴스에 저장합니다. 이것은 원본의 주소값만을 참조합니다. 이것은 성능 최적화를 위한 Swift의 방식입니다. 하지만 메모리 누수 위험이 있으므로 장기 보관을 하려면 String 값으로 다시 변환하는게 좋습니다.
문자열 보간법은 문자열 내에 변수를 포함하는 방식입니다. 역슬래시 + 괄호의 형태로 변수를 문자열에 직접 넣어서 표현합니다. 간편하지만 복잡한 수식이 들어갈 경우 성능이 저하될 수 있습니다.

## 📅 2025-05-22

### 질문 4
**Q.** Swift의 제네릭(Generic)에 대해 설명해주세요.
- 제네릭을 사용하는 이유는 무엇인가요?
- 제네릭 타입 파라미터(Generic Type Parameter)와 제네릭 타입 제약(Generic Type Constraint)은 무엇인가요?
- 제네릭을 사용할 때 주의할 점은 무엇인가요?
- 
**A.**
제네릭을 사용하는 이유는 코드 재사용성을 높이기 위해서입니다. 여러가지 타입이 비슷한 로직을 수행해야 하는 상황에서 각각의 메서드를 만들지 않고 제네릭 메서드로 만들면 하나의 메서드로 여러 타입을 모두 처리할 수 있습니다.
제네릭 타입 파라미터는 보통 T로 많이 표기하며 여기에 여러가지 타입을 직접 정의해서 사용할 수 있습니다. 예를 들어 swap<T>()라는 메서드가 있다면, String 유형을 처리할 때 swap<String>()이라고 해서 쓸 수 있습니다. 제네릭 타입 제약은 특정 타입만 쓸 수 있게 제한을 하는 것입니다. 보통 프로토콜 제약을 많이 합니다. 예를 들어 API 수신을 할 때 swap<T: Decodable>()이라고 함으로서 디코드 가능한 타입만 쓸 수 있게 하는 것입니다.
사용시 주의점은 T의 타입은 중간에 바뀔 수 없다는 것입니다. 예를 들어 swap<T>()라는 메서드에 대해 T를 Int로 정했다면 메서드의 모든 부분에서 T는 Int가 되어야 한다는 점입니다.

## 📅 2025-05-26

### 질문 5
**Q.** REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.
- REST의 제약 조건(Stateless, Cacheable, Client-Server 등)에 대해 설명해주세요.
- iOS에서 URLSession을 사용하여 네트워크 요청을 보내는 기본적인 과정은 무엇인가요?
- URLSession 외에 iOS에서 네트워크 통신을 위해 사용할 수 있는 다른 방법(라이브러리)들은 무엇이 있나요? (예: Alamofire) 어떤 장단점이 있을까요?
- REST API에서 HTTP 메서드들의 차이점(GET, POST, PUT, DELETE 등)과 각각의 용도를 설명해주세요.
- GET과 POST의 주요 차이점(멱등성, Body 유무, 캐싱 등)은 무엇인가요?
- PUT과 PATCH 메서드의 차이점은 무엇인가요? 언제 각각을 사용해야 할까요?
- HTTP 상태 코드에 대해서 설명해주세요. (1xx, 2xx, 3xx, 4xx, 5xx 그룹별 의미)
- API 요청 실패 시, 4xx 에러와 5xx 에러의 의미 차이는 무엇이며, 앱에서는 각각 어떻게 대응하는 것이 좋을까요? (예: 사용자에게 알림, 재시도 로직)
- 서버로부터 받은 JSON 데이터를 Swift 객체로 변환하는 과정(Decoding)에 대해 설명해주세요.
- Swift의 Codable 프로토콜은 어떻게 동작하나요? Encodable과 Decodable은 무엇인가요?
- JSON 키와 Swift 프로퍼티 이름이 다를 경우 어떻게 매핑하나요? (CodingKeys)

**A.**
REST API의 REST는 Representational State Transfer의 약자로서 서버와 클라이언트가 통신하기 위한 규약입니다. 제약조건은 REST API를 사용하기 위해서 따라야 하는 규칙을 말합니다. Stateless는 말 그대로 상태를 저장하지 않는다는 것입니다. 즉, 서버는 클라이언트의 상태를 저장하지 않습니다. 따라서 클라이언트의 모든 요청들은 각각이 다 처음 요청하는 것처럼 개별 처리됩니다.
iOS에서 URLSession을 사용하여 보내는 기본과정을 말씀드리겠습니다. 우선 url component를 생성합니다. 쉽게 말해서 url 주소입니다. 여기에는 https인지, host나 query가 뭔지 등의 필요 정보가 들어갑니다. 이 url을 이용해서 url request를 만듭니다. 여기에는 get 방식인지, 헤더나 바디 등의 정보가 들어갑니다.
이것을 바탕으로 URLSession 인스턴스를 만들고, 여러가지 상황을 대비해 error나 response 등의 처리를 합니다. 그리고 일반적으로는 json 디코딩을 해서 원하는 형식의 타입으로 변환합니다.
비슷한 라이브러리로는 Alamofire나 moya를 알고 있습니다. 하지만 이것들도 URLSession을 래핑해서 만든 것이므로, 기본 동작은 URLSession과 동일하고, 사용자를 위한 편의를 더 제공하고 있습니다.
REST API에서 HTTP 메서드들의 차이점(GET, POST, PUT, DELETE 등)과 각각의 용도를 말씀드리겠습니다. GET은 서버에 있는 데이터를 불러올 때, POST는 새로운 데이터를 서버에 넣고자 할 때, PUT은 서버에 있는 데이터를 변경하고자 할 떄, DELETE는 서버의 데이터를 삭제하고자 할 떄 사용합니다.
HTTP 상태 코드에 대해서 말씀드리겠습니다. 200번대는 성공, 400번대는 클라이언트 오류, 500번대는 서버 오류를 의미합니다.
Codable 프로토콜은 그 자체가 프로토콜은 아니고, typealias입니다. Encodable과 Decodable의 합성 프로토콜을 의미합니다. Encodable은 인코딩을 하기 위해, Decodable은 디코딩을 하기 위해 필요합니다.

## 📅 2025-05-27

### 질문 6
**Q.** 싱글톤 패턴(Singleton Pattern)이란 무엇이며, 어떤 경우에 사용하나요?
- 싱글톤 패턴의 장점과 단점을 설명해주세요.
- 싱글톤 패턴을 남용했을 때 발생할 수 있는 문제는 무엇인가요? (전역 상태 문제, 테스트 어려움, 의존성 숨김 등)
- Swift에서 싱글톤 패턴을 구현하는 일반적인 방법은 무엇이며, 멀티스레드 환경에서의 안전성(Thread Safety)은 어떻게 보장되나요?
- Swift에서 let 키워드를 사용하여 싱글톤 인스턴스를 선언하는 것이 왜 스레드 안전성을 보장하는 데 도움이 되나요? (dispatch_once 동작 방식 연관)

**A.**
싱글톤 패턴(Singleton Pattern)은 앱 내에서 단 하나의 인스턴스만을 만드는 디자인 패턴입니다. 일반적으로 코어 데이터나 네트워크 API 호출 등 데이터 경합이 발생할 수 있는 상황에서 많이 사용합니다. 예를 들어, 코어 데이터 인스턴스가 여러 개인데, 같은 데이터를 여러 인스턴스에서 수정한다면 어느 데이터가 맞는지 문제가 될 수 있을 것입니다. 싱글턴 패턴의 장점은 구현이 쉽고, 코드를 이해하기가 쉽다는 점입니다. 어느 상황에서든 하나의 인스턴스만 바라보면 되기 때문입니다. 단점은 일단 메모리에 올라가면 해제하기가 어렵습니다. 그리고 의존성 문제로 인해 테스트에 어려움이 있습니다. 예를 들어, 네트워크 매니저를 싱글턴으로 만들었다면, 목데이터 객체를 이용해서 테스트를 하기가 어렵습니다.
싱글턴 패턴 구현 방법은 보통 shared라는 타입 변수로 자체 인스턴스를 생성하고, 외부에서 더 이상 인스턴스를 만들지 못하도록 init을 private 접근으로 합니다. 그리고 외부에서 실제 사용할 때는 타입 뒤에 shared를 붙여 마치 타입 메서드를 사용하는 것처럼 사용합니다.
let으로 인스턴스를 생성한다는 것은 그 인스턴스를 재할당 할 수 없음을 의미하기 때문에, Swift에서 스레드 안정성을 보장합니다. 그래서 싱글턴 패턴은 static let으로 인스턴스를 생성하는 것이 권장됩니다.

## 📅 2025-05-29

### 질문 7
**Q.** 프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.

**A.**
프로세스란 앱이 실행되어 메모리에 올라간 상태를 말합니다. 즉, 현재 구동 중인 상태라고 할 수 있습니다. 스레드란 프로세스에서 실제 연산이 이뤄지는 작업 단위를 말합니다. 좀 더 자세히 말하면 앱을 실행하기 전에는 ssd 등의 저장공간에 있다가, 실행하면 메모리에 올라가면서 프로세스 상태로 되는 것입니다. 그리고 여기에서 싱글 혹은 멀티 스레드에서 연산이 이뤄지며 실제 앱이 작동하는 것입니다.
프로세스 관리는 보통 iOS에서 알아서 해줍니다. 앱은 보통 하나의 프로세스만 가지고 메모리에서 독립적인 영역을 차지합니다. 만약 메모리가 부족하거나 하면 iOS가 중요도를 따져서 백그라운드에 있는 앱들을 조정합니다. 하지만 스레드 관리는 개발자가 좀 해줘야 합니다. 스레드는 한 프로세스 내에서 메모리를 공유하기 때문에 충돌이 발생할 수도 있습니다. 그리고 UI는 메인 스레드에서만 작동하도록 해야 합니다. GCD 등을 이용해서 이를 조정해 줄 수 있습니다.
